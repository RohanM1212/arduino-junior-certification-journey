Lesson Seven (Post Lesson Reflection)

So this was the last lesson in which I had to use Tinkercad, the online circuit creation website. I might have to use it for lesson 10, since that is a self-driven project like lesson 5, but I don't know. I realized that not having a capacitor also disables me from using a servo. The reason that I had to go virtual for this lesson as well as the last one was because I was using a servo, and servos require capacitors to not overheat or damage components in a circuit. Anyway, let's move on to what I learned today. I didn't learn about any new components today. Today's lesson was geared more towards coding rather than wiring. I already knew all the concepts that were being taught today in the coding section, but I was able to code them in C++. The first thing they taught today was about switch-case conditional structure. Essentially, how it works is that it has a certain amount of "cases" or modes that can, and are, changed by certain mechanisms decided by the creator. Each of these cases do something unique. A real life example of a switch case would be a menu at a restaurant. Let's say I picked the first thing on the menu, then that would be case 0 and the procedure for cooking would be different. If I picked the second item on the menu, which would be case 1, they would not have the same procedure as case 0. That is essentially how switch case conditional structure works. You can also think about it as a bunch of if else statements, but switch structures are a lot more refined and manageable. You can imagine the difference between 5 if else statements and 5 switch statements, there would be a lot of brackets to go through. In my computer science classes in school, we don't use the Switch case conditional structure very much. We usually use if statements because we don't have to code that many conditions. In robotics, I can already see so many possibilities of its use. Today I created a windshield wiper circuit, in which we have to use switch statements. It is very similar to a real life windshield wiper, and I coded it using switch statements. Another structure they taught is for and while loops. Of course, I already knew how to do this and am very proficient in using them in Java, but I still had to learn how to code it in C++. I never doubted that for and while loops won't come in handy in robotics, but now that I can actually code them I can use them to my advantage. Let's start with the for loop. It creates an Integer variable which we can start at any value. Then, separated by a semi-colon, there is the condition. By condition I mean when the for loop will stop. And finally, separated by a semi-colon, there is the increment. Here is an example of all of this in action: We start with 0, the initial Integer, then we state a condition that i < 5, which means i can never be greater than 4, and finally we increment by saying i++ (increment by 1), or i += 2 (increment by 2). Now, the loop will do whatever is inside it, then increment the initial Integer then run whatever is inside the loop again. Whenever you use a for loop, you have to make sure that you avoid an infinite loop. An infinite loop is when the variable you create will never satisfy the condition that you create, so the loop will run forever. Now for the while loop. It just has a condition, and while that condition is true, whatever is inside the while loop will run. When using a while loop, we have to make sure that we are going to satisfy the condition, otherwise we will run into an infinite loop like before. In this case, the condition could be a Boolean and you turn it to false whenever a condition is reached. For and While loops have their own advantages and disadvantages. When creating a circuit, for example, if we want to have the LED blink a specific amount of times, the best loop to use would be the for loop. Now if we wanted the LED to keep blinking until, let's say a button is pressed, a while loop will be necessary. In a for loop you must have a certain amount of "runs" before it stops, so you cannot use it when the amount of time the code will "run" is ambiguous. In a while loop, by contrast, you can set a variable to true and set that as the condition for the while loop, but in the while loop when a certain condition is met, like button pressed, you can change the value of the Boolean inside the condition. Now, it is just a matter of efficiency, because if we want a while loop to run for a certain amount of trials, we would have to create the same Integer variable and increment it just outside the loop making the code look just a little messy. Now let's talk about my favorite part of the lesson today, designing a successful invention. Inventors have created so many inventions, but not all of them have been successful. Now what sets these inventions apart? Usability. In the case of this lesson, we are talking about windshield wipers. Mary Anderson created the first prototype of the windshield wiper, but it had one big issue, affecting its usability. The issue was the when there wasn't enough rain, the wiper dragged along the glass of the car creating a very irritating sound. This is why when Robert Kearns created another version of Anderson's wiper after taking inspiration from the human eye, it was much better received. The point isn't that Anderson took something ordinary and created something amazing out of it, the point is that Kearn's invention had much better usability than Anderson's. Now I don't know if that was on purpose, but I feel like this is a very important part of engineering. To become a successful inventor or engineer we have to consider the usability of anything we create. A great example of success due to usability is Steve Jobs. It was stated multiple times that Steve Jobs wasn't an engineer or inventor, he was just a regular guy. The only reason his products became so popular was because they were so user friendly and accessible. From the first Apple II computer to the iPhone 17 Pro Max, they all have something in common that makes them immensely successful, their usability. If some guy that wasn't an engineer, or an inventor could come up with a line of products so successful due to usability, what could inventors and engineers, with their great minds, achieve by factoring in usability? Now whenever I design something that I intend to show, I will never forget its usability. It is fascinating to me how Steve Jobs became so successful. Taking inspiration from his story is the best that I can do. 

Now for the vocab:

Affordance – What an object or component can do.
Increment – To increase by a certain amount, resulting in an amount that is more than it was previously.
Initialization – A command that creates a variable and sets its beginning value.
loop – A programming function that repeats a series of commands.
Nested conditional – A conditional placed inside another conditional. Nested conditionals provide the ability to create an outcome based on a series of decisions.

Now let's move on to the actual circuit that I built today: Basic Windshield Wiper

For the wiring of the robot, there were five components (refer to lesson_seven_windshield_wiper_circuit in media): Capacitor, Servo motor, Potentiometer, Button, and LED. Wiring them went something like this, the capacitor was connected directly to the power rail of the circuit. Both of its pins were connected to the power rail. The Servo was connected to a pin on the arduino and its ground and power were connected to the capacitor. This is to make sure that when the servo turns, it doesn't damage the other components due to its immense voltage requirement. The potentiometer was wired the same as well, the ground and power connected to the power rail of the breadboard, and third pin connected to a pin on the Arduino to allow for coding. Same with the button and LED, but they each require a resistor. Now how the flow of electricity works, since it is a parallel circuit, it first goes through the potentiometer which is used to control the delay between servo movements. At the same time the electricity flows through the button, LED, and capacitor which stores the electricity for when the servo needs it. As I said before, I didn't learn about any new components so the wiring was relatively the same as other lessons. 

Now for the code (refer to lesson_7_windshield_wiper_code in src):

In the code, the main attraction is in the loop method. This is the spot where all the behavior of the servo/windshield wiper is controlled. Here is where we implement the switch case structure. To explain how the code works, I will explain the switch structure and everything that is inside of it. In case 0, the wiper is essentially off. The servo angle is set to 0 and the delay time is set to 1000 milliseconds. This is the resting position of the wiper. In case 1, the wiper moves back and forth at a constant speed. I check whether the servo is currently at 0 degrees or 179 degrees, and then switch it to the opposite position. This creates the back and forth sweeping motion. The delay is still the same. In case 2, the servo still moves back and forth, but now the delay time depends on the potentiometer value. When the servo moves in one direction, the delay is the same, but when it moves back, the delay is mapped from the potentiometer. This is an accurate representation of a windshield wiper from a real car. Finally, in case 3, the system enters a special mode. The LED turns on, and a for loop runs five times, moving the servo back and forth with a one-second delay each time. This is a good example of when a for loop is useful, because I know exactly how many times I want the motion to repeat. After the loop finishes, the LED turns off and the wiper state resets back to 0. This case is kind of like the pulse in a real windshield wiper, but it pulses 5 times before it stops. After the switch statement, the servo is told to move to whatever angle was decided by the current case. The program then records the current time using millis() and enters a while loop. This while loop runs until the delay time has passed, but during that time, it constantly checks the button. I learned this method from my project in lesson five, where I was having the same problem. The problem was that I had to spam the button just for it to change the mode, but now nearly whenever I press the button it will change modes. 

I had a lot of fun creating this project, especially the coding portion, because it reinforced my prior knowledge of these concepts with C++ code, allowing me to use them from now on. This was done virtually, so I feel like I missed out on the full experience of working with real components and dealing with real world problems that don’t come up in simulations/online circuits. Still, the best part of this lesson was usability and how it affects inventions, and I will make sure to remember to prioritize making my designs intuitive and user-friendly in whatever I create.

